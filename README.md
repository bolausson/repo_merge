# repo_merge

A command-line tool that walks a local Git repository and merges its text files into one or more Markdown part files suitable for ingestion by an LLM or for archival. The tool preserves file contents, includes metadata (size and SHA‑1), respects `.gitignore` by default, and can produce a tree-style summary and a ZIP archive of the outputs. It also supports forced splitting of very large files to keep parts under a configured size, and it can restore a repository from the generated Markdown parts.

---

## Features
- Merge text files into Markdown parts named `<repo-name>.partNNN.md`.
- Never split a file across parts by default; each file section is kept intact.
- Optional `--force-split` to split very large files across parts so no part exceeds `MAX_PART_SIZE`.
- Configurable max part size with human-friendly values (e.g., `50M`, `200K`).
- Respects `.gitignore` by default; optional `--no-gitignore` to include everything.
- Skips binary files and lists them in the output.
- **LLM instructions** included at the top of the first part to explain format and purpose (printed with `--show-llm-instructions`).
- Summary file `<repo-name>.summary.md` with a tree showing which part contains each file (can be disabled).
- Optional ZIP archive `<repo-name>-merged.zip` containing all parts and the summary; when unzipped, files go into a folder named `<repo-name>-merged`.
- Filters and options: include only certain extensions, include hidden files, dry-run mode, progress indicator.
- Restore mode supports:
  - Restoring from a folder of `.md` parts.
  - Restoring from a `.zip` that contains the parts (parts may be inside a folder in the zip).
  - Restoring from a wildcard (e.g., `repo-merged.part*.md`).
  - Listing files found in parts (`--list-files`).
  - Verifying restored files against SHA‑1 metadata (`-c/--check`).
  - Saving restored repo to a new name or path (`-n/--new-name`).

---

## Installation
1. Ensure you have Python 3.8+ installed.
2. Save the script as `repo_merge.py` and make it executable if desired:
   ```bash
   chmod +x repo_merge.py
   ```
3. Run the script from a shell. No external Python packages are required.

---

## LLM onboarding prompt

Use this prompt to put an LLM into collaboration mode before uploading or pasting the generated Markdown parts. It instructs the model to read and follow the `LLM_INSTRUCTION` block in the first part and to treat the parts as the authoritative repository contents.

```
Hej, I have uploaded a set of Markdown files generated by repo_merge.py.
The very first part file begins with an "LLM INSTRUCTION" block that describes the format and conventions of the archive.
Please read and follow those instructions carefully when interpreting the files.

After that, treat the uploaded Markdown files as the repository contents.
Each part begins with metadata and then lists files with headers, SHA‑1 hashes, and fenced code blocks.
At the end, there may be a summary file showing a tree of files and which part they are in.

I want you to act as my collaborator on this codebase. Please:
- Parse the uploaded Markdown files and treat them as the repository contents.
- Be able to navigate the file tree and reference specific files by their relative paths.
- Help me review, refactor, and extend the code. For example, I may ask you to explain how a function works, suggest improvements, add new features, or fix bugs.
- When you provide code changes, show the full updated file or the relevant diff in fenced code blocks.
- Keep track of which part/file the code comes from so we can maintain consistency across the repository.

To start, please confirm you understand the format of the uploaded Markdown files, including the "LLM INSTRUCTION" block in the first file,
and that you can work with me on the code they contain.

Thank you in advance for your help – I really appreciate it.
```

---

## Quick start examples

### Merge a repository (basic)
```bash
python repo_merge.py -g /path/to/my-repo
```
Output: `my-repo.part001.md`, `my-repo.part002.md`, ...

### Merge and set max part size to 100 MB
```bash
python repo_merge.py -g /path/to/my-repo -m 100M
```

### Merge only `.py` and `.md` files and include hidden files
```bash
python repo_merge.py -g /path/to/my-repo -e .py,.md --include-hidden
```

### Dry-run to preview parts (no files written)
```bash
python repo_merge.py -g /path/to/my-repo -x
```

### Save outputs to a specific folder
```bash
python repo_merge.py -g /path/to/my-repo -o myrepo.part001.md -s /path/to/save
```

### Produce parts, summary, and a ZIP archive
```bash
python repo_merge.py -g /path/to/my-repo -z -s /path/to/save
```
Result: `my-repo.part001.md`, `my-repo.part002.md`, `my-repo.summary.md`, and `my-repo-merged.zip` (contains `my-repo-merged/` folder with the files).

### Force split very large files
```bash
python repo_merge.py -g /path/to/my-repo --force-split -m 50M
```

---

## Restore examples

### Restore from a folder of parts
```bash
python repo_merge.py -r /path/to/parts-folder -n restored-repo
```

### Restore from a zip file
```bash
python repo_merge.py -r /path/to/myrepo-merged.zip -n restored-repo
```

### Restore using a wildcard
```bash
python repo_merge.py -r "myrepo.part*.md" -n restored-repo
```

### List files contained in parts (do not restore)
```bash
python repo_merge.py -r "myrepo.part*.md" --list-files
```

### Restore and verify checksums
```bash
python repo_merge.py -r "myrepo.part*.md" -n restored-repo -c
```

### Restore with EOL normalization
```bash
python repo_merge.py -r "myrepo.part*.md" -n restored-repo --normalize-eol lf
```

---

## CLI options (summary)
- `-g, --git-repo <path>` — Path to the repository root (merge mode).
- `-o, --output <path>` — Base output filename or path. Defaults to `<repo-name>.part001.md`.
- `-m, --max-size <size>` — Maximum bytes per part (e.g., `50M`, `200K`). Default: `50M`.
- `-e, --extensions <list>` — Comma-separated list of file extensions to include (e.g., `.py,.md` or `py,md`).
- `-x, --dry-run` — Do not write files; show how many parts would be produced and list files per part.
- `--no-gitignore` — Ignore `.gitignore` and include all files.
- `--include-hidden` — Include hidden files and folders (names starting with `.`).
- `--no-summary` — Do not create the `<repo-name>.summary.md` summary file.
- `-z, --zip` — Create a zip archive named `<repo-name>-merged.zip` containing all parts and the summary.
- `--force-split` — Force split very large input files across parts so no part exceeds `MAX_PART_SIZE`.
- `-r, --restore <source>` — Restore a repository from Markdown parts, a zip file, or a wildcard path (e.g., `/path/to/*.md`).
- `-n, --new-name <name>` — New base folder name or path for restored repository. If omitted, original `repo_name` from metadata is used.
- `-c, --check` — When restoring, verify restored files against SHA‑1 checksums in the Markdown metadata.
- `--list-files` — When restoring, list files found in parts and which parts they appear in, then exit.
- `-s, --save-to <folder>` — Folder path where merged markdown files and zip should be saved.
- `--force-overwrite` — Do not prompt before overwriting existing files or directories.
- `--normalize-eol {preserve,lf,crlf}` — Normalize line endings when writing parts and when restoring. Default: `preserve`.
- `--verify` — After merging, perform a round-trip verification (merge → restore → compare checksums).
- `--show-llm-instructions` — Print the embedded LLM instructions (the `LLM_INSTRUCTIONS` block) and exit.
- `--show-llm-prompt` — Print a ready-to-use user prompt for an LLM and exit.
- `-t, --txt` — Append `.txt` to all generated Markdown files (e.g., `.part001.md.txt`) for compatibility with LLMs that disallow `.md` uploads.

---

## Output format and conventions (detailed)
The generated Markdown parts are designed to be machine-friendly and LLM-friendly.

### Top metadata block
- Each part begins with a YAML-like fenced block:
  ```yaml
  merged_repo_file: v1
  generated_by: "repo_merge.py"
  generated_at: 2025-12-01T00:00:00Z
  repo_root: "/absolute/path/where/repo/was-read"
  repo_name: "my-repo"
  notes: "short notes"
  ```
- `merged_repo_file` indicates the archive format version.
- `generated_by` should be `"repo_merge.py"`.
- `generated_at` is an ISO 8601 UTC timestamp with trailing `Z`.
- `repo_root` is informational (absolute path on the machine that produced the parts).
- `repo_name` is the repository directory name (used as default output name).

### LLM instruction block
- The **first part** includes a clear `LLM_INSTRUCTION` block (human-readable) that explains the archive format and how to parse it. Use `--show-llm-instructions` to print it.

### File sections
- Each file is represented as:
  ```
  ### FILE: `relative/path/to/file.ext`
  - **size:** <bytes> bytes
  - **sha1:** `<40-hex-chars>`
  
  ```<fence>
  <file contents exactly as read (UTF-8 with replacement)>
  <closing fence>
  ```
  ```
- **Fences**: the generator chooses a fence length of 3 or more backticks that is longer than any run of backticks inside the file content to avoid premature termination. The parser accepts variable-length fences and matches the closing fence exactly.
- **Splits**: if `--force-split` was used, very large files may be split across parts. In that case the same `### FILE:` header may appear in multiple parts; concatenate the content chunks in part order to reconstruct the file.
- **No extra newlines**: the writer preserves file content exactly (after UTF‑8 decoding with replacement) and does not add an extra blank line after the code fence. Restored files should match original SHA‑1 checksums when EOL normalization is not applied.

### End-of-archive lists (last part)
- `## Ignored by .gitignore` — list of paths intentionally excluded (may be omitted).
- `## Skipped binary files` — list of binary files that were not included.

---

## Restore behavior and validation
- The restore process:
  1. Validates each candidate part file (checks for YAML metadata, `generated_by`, `### FILE:` headers, and fenced blocks).
  2. Prints warnings for parts or sections that do not match the expected format and **continues** with other valid parts.
  3. Reconstructs directory structure and writes files using the relative paths exactly as provided.
  4. Concatenates chunks for files split across parts.
  5. Optionally verifies SHA‑1 checksums (`-c/--check`) and reports mismatches.
  6. Respects `--normalize-eol` when writing restored files (so checksums may differ if you normalize EOLs).

- If the restore target directory or files already exist, the script prompts for action (overwrite, merge, cancel) unless `--force-overwrite` is used.

---

## Round-trip verification
- Use `--verify` after merging to perform an automatic round-trip test:
  - The script merges the repo into parts, restores those parts into a temporary directory, and compares SHA‑1 checksums of the restored files against the originals (respecting `--normalize-eol` if set).
  - The command exits non-zero if verification fails.

---

## LLM integration helpers
- `--show-llm-instructions` prints the `LLM_INSTRUCTIONS` block that appears at the top of the first part. This block explains the archive format and parsing rules for any LLM.
- `--show-llm-prompt` prints a ready-to-use user prompt you can paste to an LLM to put it into collaboration mode (parsing the parts, navigating the tree, verifying checksums, and helping with code changes).

---

## Notes and tips
- Large single files: by default, if a file section exceeds `--max-size`, it is written whole into its own part (which may exceed the limit). Use `--force-split` to ensure no part exceeds the limit.
- `.gitignore`: by default the script respects `.gitignore`. Use `--no-gitignore` to include everything. The script also treats ignored **folders** as ignored.
- Binary files: binary files are detected and skipped; they are listed under `## Skipped binary files` in the last part.
- Script exclusion: the script excludes itself from the merged output.
- Overwrite prompts: the script will prompt before overwriting existing output files or restore targets unless `--force-overwrite` is specified.
- EOL normalization: if you need exact SHA‑1 round-trip matching, avoid normalizing EOLs or use the same `--normalize-eol` setting for both merge and restore.
- Dry-run: use `-x` to preview parts and the planned summary without writing files.

---

## Troubleshooting
- If `git` is not available, the script falls back to a simple `.gitignore` parser; results may differ from `git` behavior for complex ignore rules.
- If the script fails to read a file due to encoding issues, it reads with `errors="replace"` so the file content is still included with replacement characters.
- If a README or other Markdown file contains backtick fences, the generator will choose a longer fence so the file is not truncated.
